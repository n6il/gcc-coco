;;-
;;- $Header: /cvsroot-fuse/gcc-coco/libc-coco-rsdos/gcc/m6809/m6809.md,v 1.2 2004/03/26 07:10:58 skwirl42 Exp $
;;-
;;-------------------------------------------------------------------
;; FILE: m6809.md
;; SCCS: @(#)m6809.md	1.2 SAL 1/22/92
;;-------------------------------------------------------------------
;;- Machine description for GNU compiler
;;-
;;- MC6809 Version by Tom Jones (jones@sal.wisc.edu)
;;- Space Astronomy Laboratory
;;- University of Wisconsin at Madison
;;-
;;-  minor changes to adapt it to gcc-2.5.8 by Matthias Doerfel
;;-  ( msdoerfe@informatik.uni-erlangen.de )
;;-  also added #pragma interrupt (inspired by gcc-6811)
;;- 
;;-  Copyright (C) 1989 Free Software Foundation, Inc.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 1, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.


;;- Instruction patterns.  When multiple patterns apply,
;;- the first one in the file is chosen.
;;-
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
;;-
;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;; Put tstsi first among test insns so it matches a CONST_INT operand.

;;--------------------------------------------------------------------
;;-  Test
;;--------------------------------------------------------------------

(define_insn "tstsi"
  [(set (cc0)
	(match_operand:SI 0 "register_operand" "r"))]
  ""
  "cmp%0\\t#0\\t;tstsi: R:%0")

(define_insn "tsthi"
  [(set (cc0)
	(match_operand:HI 0 "register_operand" "r"))]
  ""
  "cmp%0\\t#0\\t;tsthi: R:%0")

(define_insn "tstqi"
  [(set (cc0)
	(match_operand:QI 0 "byte_operand" "qm"))]
  ""
 "*
{
    if (GET_CODE (operands[0]) == MEM)
	return \"tst\\t%0\\t;tstqi: MEM:%0\";
    else
	return \"tst%0\\t\\t;tstqi: R:%0\";
}")

(define_insn ""
  [(set (cc0)
        (match_operand:SI 0 "memory_operand" "m"))]
  ""
  "tst\\t%0\\t;tstsi: MEM:%0")

;;--------------------------------------------------------------------
;;- Compare
;;--------------------------------------------------------------------
;; Put cmpsi first among compare insns so it matches two CONST_INT operands.


;;- cmpsi for register to memory or register compares
(define_insn "cmpsi"
  [(set (cc0)
	(compare (match_operand:SI 0 "general_operand" "ad,g,??ad")
		 (match_operand:SI 1 "general_operand" "g,da,da")))]
  ""
  "*
{
    if ((REG_P (operands[0])) && (REG_P (operands[1]))) {
	output_asm_insn (\"pshs\\t%1\\t;cmpsi: R:%1 with R:%0\", operands);
	return \"cmp%0\\t,s++\\t;cmpsi:\";
    }
    if (GET_CODE (operands[0]) == REG)
	return \"cmp%0\\t%1\\t;cmpsi:\";
    else {
	cc_status.flags |= CC_REVERSED;
	return \"cmp%1\\t%0\\t;cmpsi:(R)\";
    }
}")

;;- cmphi for register to memory or register compares
(define_insn "cmphi"
  [(set (cc0)
	(compare (match_operand:HI 0 "general_operand" "ad,g,??ad")
		 (match_operand:HI 1 "general_operand" "g,da,da")))]
  ""
  "*
{
    if ((REG_P (operands[0])) && (REG_P (operands[1]))) {
	output_asm_insn (\"pshs\\t%1\\t;cmphi: R:%1 with R:%0\", operands);
	return \"cmp%0\\t,s++\\t;cmphi:\";
    }
    if (GET_CODE (operands[0]) == REG)
	return \"cmp%0\\t%1\\t;cmphi:\";
    else {
	cc_status.flags |= CC_REVERSED;
	return \"cmp%1\\t%0\\t;cmphi:(R)\";
    }
}")


(define_insn "cmpqi"
  [(set (cc0)
	(compare (match_operand:QI 0 "byte_operand" "q,mK")
		 (match_operand:QI 1 "byte_operand" "mK,q")))]
  ""
  "*
{
    if (GET_CODE (operands[0]) == REG)
      return \"cmp%0\\t%1\\t;cmpqi:\";
    else {
      cc_status.flags |= CC_REVERSED;
      return \"cmp%1\\t%0\\t;cmpqi:(R)\";
    }
}")

;;--------------------------------------------------------------------
;;-  Move
;;--------------------------------------------------------------------

;;-(define_insn "movdi"
;;-  [(set (match_operand:DI 0 "memory_operand" "=m")
;;-	(match_operand:DI 1 "memory_operand"  "m"))]
;;-  ""
;;-  "*
;;-{
;;-    return \".bogus ;movdi: %1 -> %0\";
;;-}")

;;- new insn for arrays
;;-(define_insn ""
;;-  [(set (match_operand:QI 0 "byte_operand" "q,q")
;;-	(mem:QI (plus:SI  (match_operand:SI 1 "general_operand"  "d,a")
;;-			  (match_operand:SI 2 "general_operand"  "a,d"))))]
;;-  ""
;;-  "*
;;-{
;;-    return \".bogus ;movqi: %1,%2 -> %0\";
;;-}")

;;- new insn for arrays
;;-(define_insn ""
;;-  [(set (mem:QI (plus:HI  (match_operand:HI 0 "reg_operand"  "a")
;;-                          (match_operand:HI 1 "reg_operand"  "a")))
;;-        (match_operand:QI 2 "byte_operand" "qi"))]
;;-  ""
;;-  "*
;;-{
;;-    return \".maz ;movqi: %2 -> %1,%0 \";
;;-}")


;;-
(define_insn ""
  [(set (match_operand:SI 0 "general_operand"  "=r")
	(match_operand:SI 1 "memory_operand"  "m"))]
  ""
  "*
{
    return \"ld%0\\t#%1\\t;movsi: #<symbol_ref> -> %0\";
}")


(define_insn "movsi"
  [(set (match_operand:SI 0 "general_operand" "=r,r,mi")
	(match_operand:SI 1 "general_operand"  "r,mi,r"))]
  ""
  "*
{
    if (REG_P (operands[0])) {

	if (REG_P (operands[1])) {
	    if (REGNO (operands[0]) != REGNO (operands[1]))
		return \"tfr\\t%1,%0\\t;movsi: R:%1 -> R:%0\";
	    else
		return \";redundant movsi: R:%1 -> R:%0\";
	}

	if ((operands[1] == const0_rtx) && (D_REG_P (operands[0])))
	    return \"clra\\t\\t;movsi: ZERO -> R:%0\;clrb\";
	else
	    return \"ld%0\\t%1\\t;movsi: %1 -> R:%0\";
    }

    if ((push_operand (operands[0], SImode))
	&& (REG_P (operands[1])))
	    return \"pshs\\t%1\\t;movsi: push R:%1\";

    if (REG_P (operands[1]))
	return \"st%1\\t%0\\t;movsi: R:%1 -> %0\";

    return \".bogus ;movsi: %1 -> %0\";
}")


(define_insn "movhi"
  [(set (match_operand:HI 0 "general_operand" "=r,r,mi")
	(match_operand:HI 1 "general_operand"  "r,mi,r"))]
  ""
  "*
{
    if (REG_P (operands[0])) {

	if (REG_P (operands[1])) {
	    if (REGNO (operands[0]) != REGNO (operands[1]))
		return \"tfr\\t%1,%0\\t;movhi: R:%1 -> R:%0\";
	    else
		return \";redundant movhi: R:%1 -> R:%0\";
	}

	if ((operands[1] == const0_rtx) && (D_REG_P (operands[0])))
	    return \"clra\\t\\t;movhi: ZERO -> R:%0\;clrb\";
	else
	    return \"ld%0\\t%1\\t;movhi: %1 -> R:%0\";
    }

    if ((push_operand (operands[0], SImode))
	&& (REG_P (operands[1])))
	    return \"pshs\\t%1\\t;movhi: push R:%1\";

    if (REG_P (operands[1]))
	return \"st%1\\t%0\\t;movhi: R:%1 -> %0\";

    return \".bogus ;movhi: %1 -> %0\";
}")


;;- clrqi
(define_insn "clrqi"
  [(set (match_operand:QI 0 "byte_operand" "=q,=m")
     (const_int 0))]
  ""
  "@
  clr%0\\t\\t;clrqi REG:%0
  clr\\t%0\\t;clrqi %0")


;;- movqi
(define_insn "movqi"
  [(set (match_operand:QI 0 "byte_operand" "=q,q,mi")
	(match_operand:QI 1 "byte_operand" "q,mi,q"))]
  ""
  "*
{
    if (REG_P (operands[0])) {
	if (REG_P (operands[1])) {
	    if (REGNO (operands[0]) != REGNO (operands[1]))
		return \"tfr\\t%1,%0\\t;movqi: R:%1 -> R:%0\";
	    else
		return \";redundant movqi: R:%1 -> R:%0\";
	}

	if (operands[1] == const0_rtx)
	    return \"clr%0\\t\\t;movqi: ZERO -> R:%0\";
	else
	    return \"ld%0\\t%1\\t;movqi: %1 -> R:%0\";
    }

    if (GET_CODE (operands[1]) == REG)
	return \"st%1\\t%0\\t;movqi: R:%1 -> %0\";

    if ((push_operand (operands[0], QImode))
	&& (GET_CODE (operands[1]) == REG))
	return \"pshs\\t%0\\t;movqi: push R:%0\";
    else
	return \".bogus ;movqi: %1 -> %0\";
}")




;; replaced with QI instead of HI
;;- set high byte of 16-bit word
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=q,q,m")
      (subreg:QI (match_operand:HI 1 "general_operand" "d,m,d") 1))]
  ""
  "*
{
  if (REG_P (operands[0]) && (operands[1] == const0_rtx))
    return \"clr%0\\t\\t;movmsb:\";
  if ((REG_P (operands[0])) && (D_REG_P (operands[1])))
    return \"tfr\\ta,%0\\t;movmsb:\";
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"sta\\t%0\\t;movmsb:\";
  if (REG_P (operands[0]) && (GET_CODE (operands[1]) == MEM))
    return \"ld%0\\t%1\\t;movmsb:\";
  else
    return \".bogus ;movmsb: %1 -> %0\";
}")

;; replaced with QI instead of HI
;;- set low byte of 16-bit word
;; was =q,q,m
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=d,d,m")
      (subreg:QI (match_operand:HI 1 "general_operand" "d,m,d") 0))]
  ""
  "*
{
  if (REG_P (operands[0])) {
	if (operands[1] == const0_rtx)
	    return \"clr%0\\t\\t;movlsb: ZERO -> R:%0\";
	if (D_REG_P (operands[1]))
	    return \"tfr\\tb,%0\\t;movlsb: R:%1 -> R:%0\";
	if (GET_CODE (operands[1]) == MEM)
	    return \"ld%0\\t%L1\\t;movlsb: %1 -> R:%0 (with corrected memadress)\";
  }
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsb: R:%1 -> %0\";
  else
    return \".bogus ;movlsb: %1 -> %0\";
}")

;; replaced with QI instead of HI
;;- set high byte of 16-bit word
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=q,q,m")
      (subreg:QI (match_operand:SI 1 "general_operand" "d,m,d") 1))]
  ""
  "*
{
  if (REG_P (operands[0]) && (operands[1] == const0_rtx))
    return \"clr%0\\t\\t;movmsb:\";
  if ((REG_P (operands[0])) && (D_REG_P (operands[1])))
    return \"tfr\\ta,%0\\t;movmsb:\";
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"sta\\t%0\\t;movmsb:\";
  if (REG_P (operands[0]) && (GET_CODE (operands[1]) == MEM))
    return \"ld%0\\t%1\\t;movmsb:\";
  else
    return \".bogus ;movmsb: %1 -> %0\";
}")

;; replaced with QI instead of HI
;;- set low byte of 16-bit word
;; was =q,q,m
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=d,d,m")
      (subreg:QI (match_operand:SI 1 "general_operand" "d,m,d") 0))]
  ""
  "*
{
  if (REG_P (operands[0])) {
	if (operands[1] == const0_rtx)
	    return \"clr%0\\t\\t;movlsb: ZERO -> R:%0\";
	if (D_REG_P (operands[1]))
	    return \"tfr\\tb,%0\\t;movlsb: R:%1 -> R:%0\";
	if (GET_CODE (operands[1]) == MEM)
	    return \"ld%0\\t%L1\\t;movlsb: %1 -> R:%0 (with corrected memadress)\";
  }
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsb: R:%1 -> %0\";
  else
    return \".bogus ;movlsb: %1 -> %0\";
}")

;;- set low byte of 16-bit word
;; was =q,q,m
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=q,q,m")
      (subreg:QI (match_operand:HI 1 "general_operand" "d,m,d") 0))]
  ""
  "*
{
  if (REG_P (operands[0])) {
        if (operands[1] == const0_rtx)
            return \"clr%0\\t\\t;movlsbqihi: ZERO -> R:%0\";
        if (D_REG_P (operands[1]))
            return \"tfr\\tb,%0\\t;movlsbqihi: R:%1 -> R:%0\";
        if (GET_CODE (operands[1]) == MEM)
            return \"ld%0\\t%L1\\t;movlsbqihi: %1 -> R:%0 (with corrected memadress)\";
  }
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsbqihi: R:%1 -> %0\";
  else
    return \".bogus ;movlsbqihi: %1 -> %0\";
}")


;; - set low byte of 16-bit word -- QI:QI-version
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=d,d,m")
      (subreg:QI (match_operand:QI 1 "byte_operand" "q,m,q") 0))]
  ""
  "*
{
  if (REG_P (operands[0])) {
        if (operands[1] == const0_rtx)
            return \"clr%0\\t\\t;movlsb: ZERO -> R:%0\";
        if (D_REG_P (operands[1]))
            return \"tfr\\tb,%0\\t;movlsb: R:%1 -> R:%0\";
        if (GET_CODE (operands[1]) == MEM)
            return \"ld%0\\t%1\\t;movlsb: %1 -> R:%0 (with uncorrected memadress)\";
  }
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsb: R:%1 -> %0\";
  else
    return \".bogus ;movlsb: %1 -> %0\";
} ")


(define_insn "movstricthi"
  [(set (strict_low_part
      (subreg:HI (match_operand:SI 0 "general_operand" "d,m,d") 0))
	(match_operand:HI 1 "byte_operand" "q,q,m"))]
  ""
  "*
{
  if (REG_P (operands[0])) {
    if (operands[1] == const0_rtx)
	return \"clrb\\t\\t;movstricthi: ZERO -> R:%0\";
    if (REG_P (operands[1]))
	return \"tfr\\t%1,b\\t;movstricthi: R:%1 -> R:%0\";
    else
	return \"ldb\\t%L1\\t;movstricthi: %1 -> R:%0\";
  }
  if (REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%L0\\t;movstricthi: R:%1 -> %0\";
  else
    return \".bogus ;movstricthi: %1 -> %0\";
}")


;;--------------------------------------------------------------------
;;-  Swap registers
;;--------------------------------------------------------------------
(define_insn "swapsi"
  [(set (match_operand:SI 0 "register_operand" "+r")
	(match_operand:SI 1 "register_operand" "+r"))
   (set (match_dup 1) (match_dup 0))]
  ""
  "exg\\t%1,%0\\t;swapsi: R:%1 <-> R:%0")

(define_insn "swapqi"
  [(set (match_operand:QI 0 "byte_reg_operand" "+q")
	(match_operand:QI 1 "byte_reg_operand" "+q"))
   (set (match_dup 1) (match_dup 0))]
  ""
  "exg\\t%1,%0\\t;swapqi: R:%1 <-> R:%0")


;;--------------------------------------------------------------------
;;-  Extension and truncation insns.
;;--------------------------------------------------------------------
;; Those for integer source operand
;; are ordered widest source type first.

;;- Use this pattern to match the insn for variable subscripts.

;;-(define_expand "extendhisi2"
;;-  [(set (match_operand:SI 0 "general_operand" "=d,g")
;;-	(sign_extend:SI (match_operand:HI 1 "general_operand" "q,g")))]
;;-    ""
;;-    "
;;-{
;;-    rtx breg;
;;-    rtx dreg;
;;-    rtx sint;
;;-
;;-    breg = gen_rtx (REG, HImode, 0);
;;-    dreg = gen_rtx (REG, SImode, 0);
;;-    emit_insn (gen_rtx (SET, HImode, breg, operands[1]));
;;-    sint = (gen_rtx (SIGN_EXTEND, SImode, breg));
;;-    emit_insn (gen_rtx (SET, SImode, dreg, sint));
;;-
;;-    /*** assume extended value is in R0 ***/
;;-    if (!D_REG_P (operands[0])) {
;;-	emit_move_insn (operands[0], gen_rtx (REG, SImode, 0));
;;-    }
;;-    DONE;
;;-}")
;;-


(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=g")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "g")))]
  ""
  "; extendhisi2: %1 -> %0"
)

(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
	(sign_extend:SI (match_operand:QI 1 "byte_operand" "qmi")))]
  ""
  "*
{
    if (REG_P (operands[1])) {
	if (REGNO (operands[1]) == 8)
	    output_asm_insn (\"tfr\\ta,b\\t;extendqisi: R:%1 -> R:%0\;sex\", operands);
	else
	    output_asm_insn (\"sex\\t\\t;extendqisi: R:%1 -> R:%0\", operands);
    }
    else {
	output_asm_insn (\"ldb\\t%1\\t;extendqisi: %1 -> R:%0\;sex\", operands);
    }
    return \"\";
}")

;;-
(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
        (sign_extend:HI (match_operand:QI 1 "byte_operand" "qmi")))]
    ""
    "*
{
    if (REG_P (operands[1])) {
	if (REGNO (operands[1]) == 8)
	    output_asm_insn (\"tfr\\ta,b\\t;extendqihi: R:%1 -> R:%0\;sex\", operands);
	else
	    output_asm_insn (\"sex\\t\\t;extendqihi: R:%1 -> R:%0\", operands);
    }
    else {
	output_asm_insn (\"ldb\\t%1\\t;extendqihi: %1 -> R:%0\;sex\", operands);
    }
    return \"\";
}")

;;-


(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,m,?m")
	(const_int 0))
   (set (strict_low_part (subreg:HI (match_dup 0) 0))
	(match_operand:HI 1 "general_operand" "qm,q,m"))]
  ""
  "*
{
    if (D_REG_P (operands[0])) {
	if (REG_P (operands[1])) {
	    if (REGNO (operands[1]) == 8)
		output_asm_insn (\"tfr\\ta,b\", operands);
	    return \"clra\\t\\t;zero_extendhisi: R:%1 -> R:%0\";
	}
	if (GET_CODE (operands[1]) == MEM)
	    return \"ldb\\t%1\\t;zero_extendhisi: %1 -> R:d\;clra\";
    }

    if ((REG_P (operands[1])) && (GET_CODE (operands[0]) == MEM))
	return \"clr\\t%0\\t;zero_extendhisi: R:%1 -> %0\;st%1\\t%L0\";

    if ((GET_CODE (operands[0]) == MEM) && (GET_CODE (operands[1]) == MEM)) {
	return \"clr\\t%0\\t;zero_extendhisi: R:%1 -> %0\;lda\\t%1\;sta\\t%L0\";
    }
    else
	return \".bogus ;zero_extendhisi: %1 -> %0\";
}")



(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "general_operand" "=d")
        (zero_extend:HI (match_operand:QI 1 "general_operand" "miq")))]
  ""
  "*
{
    if (D_REG_P (operands[0])) {
        if (REG_P (operands[1])) {
            if (REGNO (operands[1]) == 8)
                output_asm_insn (\"tfr\\ta,b\", operands);
            return \"clra\\t\\t;zero_extendqihi: R:%1 -> R:%0\";
        }
        if (GET_CODE (operands[1]) == MEM)
            return \"ldb\\t%1\\t;zero_extendqihi: %1 -> R:d\;clra\";
    }

    if ((REG_P (operands[1])) && (GET_CODE (operands[0]) == MEM))
        return \"clr\\t%0\\t;zero_extendqihi: R:%1 -> %0\;st%1\\t%L0\";

    if ((GET_CODE (operands[0]) == MEM) && (GET_CODE (operands[1]) == MEM)) {
        return \"clr\\t%0\\t;zero_extendqihi: R:%1 -> %0\;lda\\t%1\;sta\\t%L0\";
    }
    else
	return \".bogus ;zero_extendqihi2: %1 -> %0\";
}")

;;--------------------------------------------------------------------
;;-  Fix-to-float conversion insns.
;;--------------------------------------------------------------------
;; Note that the ones that start with SImode come first.
;; That is so that an operand that is a CONST_INT
;; (and therefore lacks a specific machine mode).
;; will be recognized as SImode (which is always valid)
;; rather than as HImode or QImode.


;;--------------------------------------------------------------------
;;-  Float-to-fix conversion insns.
;;--------------------------------------------------------------------


;;--------------------------------------------------------------------
;;- All kinds of add instructions.
;;--------------------------------------------------------------------

;;- addsi3
(define_insn "addsi3"
  [(set          (match_operand:SI 0 "register_operand" "=d,  =a")
     (plus:SI (match_operand:SI 1 "general_operand"  "%0,  %a")
           (match_operand:SI 2 "general_operand"  "mi???r,id")))]
  ""
  "*
{
    if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
      if(D_REG_P(operands[2])){
        output_asm_insn (\"lslb\\t\\t;addhi: R:%0 += R:%2\", operands);
        return \"rola\\t\\t;also R:%0 *= 2\";
      }
      else{
        output_asm_insn (\"pshs\\t%2\\t;addhi: R:%0 += R:%2\", operands);
        return \"add%0\\t,s++\";
      }
    }

   if (D_REG_P (operands[0])) {
        return \"add%0\\t%2\\t;addhi: R:%0 += %2\";
   }
   if(A_REG_P (operands[0])){
        if(A_REG_P (operands[1])){
            if(D_REG_P (operands[2]))
                return \"lea%0\\t%2,%1\\t;addhi: R:%0 = R:%1 + R:%2\";
            else
                return \"lea%0\\t%a2,%1\\t;addhi: R:%0 = R:%1 + %2\";
        }
        else{
            if(D_REG_P (operands[1]))
                return \"lea%0\\t%1,%2\\t;addhi: R:%0 = R:%2 + R:%1\";
            else
                return \"lea%0\\t%a1,%2\\t;addhi: R:%0 = R:%2 + %1\";
        }
    }
    else
        return \".bogus\";
}")


;;-
;;- Neue Version von Ulrich Boetzel
;;-
;; fuer s := s+Memory muss eine Interrupt-sichere Version gefunden werden!!
(define_insn "addhi3"
  [(set (match_operand:HI 0 "register_operand" "=d,  =a, =a, !=a")
        (plus:HI (match_operand:HI 1 "register_operand" "%0,   a,  0, !a")
                 (match_operand:HI 2 "general_operand"  "mi!r,id, !m, !a")
  ))]
  ""
  "*
{
    if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
        output_asm_insn (\"pshs\\t%2\\t;addhi: R:%0 += R:%2\", operands);
        return \"add%0\\t,s++\";
    }

    if (D_REG_P (operands[0])) {
        return \"add%0\\t%2\\t;addhi: R:%0 += %2\";
    }
    if(A_REG_P (operands[0])){
        if(A_REG_P (operands[1])){
            if(GET_CODE (operands[2]) == MEM){
              output_asm_insn (\"exg\\td,%0\\t;addhi: R:%0 = R:%1 + %2\", 
						operands);
              output_asm_insn (\"addd\\t%2\", operands);
              return \"exg\\td,%0\";
            }
            else if(D_REG_P (operands[2]))
                return \"lea%0\\t%2,%1\\t;addhi: R:%0 = R:%1 + R:%2\";
            else if(A_REG_P (operands[2])){
              output_asm_insn (\"pshs\\td\\t;addhi: R:%0 = R:%1 + R:%2\", 
						operands);
              output_asm_insn (\"tfr\\t%1,d\", operands);
              output_asm_insn (\"lea%0\\td,%2\", operands);
              return \"puls\\td\";
            }
            else
              return \"lea%0\\t%a2,%1\\t;addhi: R:%0 = R:%1 + %2\";
        }
        else{
            if(D_REG_P (operands[1]))
                return \"lea%0\\t%1,%2\\t;addhi: R:%0 = R:%2 + R:%1\";
            else
                return \"lea%0\\t%a1,%2\\t;addhi: R:%0 = R:%2 + %1\";
        }
    }
    else
        return \".bogus\";
}")


(define_insn "addqi3"
  [(set (match_operand:QI 0 "byte_operand" "=q,m")
	(plus:QI (match_operand:QI 1 "byte_operand" "%0,0")
		 (match_operand:QI 2 "general_operand" "mi,I")))]
  ""
  "*
{
    if ((GET_CODE (operands[0]) == MEM) && (operands[2] == const1_rtx))
	return \"inc\\t%0\\t;addqi: %0 += 1\";
    if ((GET_CODE (operands[0]) == REG) && (operands[2] == const1_rtx))
	return \"inc%0\\t\\t;addqi: R:%0 += 1\";
    else
	return \"add%0\\t%2\\t;addqi: R:%0 += %2\";
}")

;;--------------------------------------------------------------------
;;- Subtract instructions.
;;--------------------------------------------------------------------
(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,a")
	(minus:SI (match_operand:SI 1 "register_operand" "0,0")
		 (match_operand:SI 2 "general_operand" "mi?r,i")))]
  ""
  "*
{
    if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
	output_asm_insn (\"pshs\\t%2\\t;subsi: R:%0 -= R:%2\", operands);
	return \"sub%0\\t,s++\";
    }
    if (D_REG_P (operands[0])) {
	return \"sub%0\\t%2\\t;subsi: R:%0 -= %2\";
    }
    else
	return \"lea%0\\t%n2,%1\\t;subsi: R:%0 = R:%1 + %n2\";
}")


(define_expand "subgen"
  [(set (match_operand:SI 0 "general_operand" "=g")
	(minus:SI (match_operand:SI 1 "general_operand" "0")
		 (match_operand:SI 2 "general_operand" "g")))]
    ""
    "
{
    rtx sum;

    sum = (gen_rtx (PLUS, SImode, operands[1],
	negate_rtx (SImode, operands[2])));
    emit_insn (gen_rtx (SET, SImode, operands[0], sum));
    DONE;
}")
    
(define_insn "subhi3"
  [(set (match_operand:HI 0 "register_operand" "=d,a")
        (minus:HI (match_operand:HI 1 "register_operand" "0,0")
                 (match_operand:HI 2 "general_operand" "mi?r,i")))]
  ""
  "*
{
    if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
        output_asm_insn (\"pshs\\t%2\\t;subhi: R:%0 -= R:%2\", operands);
        return \"sub%0\\t,s++\";
    }
    if (D_REG_P (operands[0])) {
        return \"sub%0\\t%2\\t;subhi: R:%0 -= %2\";
    }
    else
        return \"lea%0\\t%n2,%1\\t;subhi: R:%0 = R:%1 + %n2\";
}")
 

;;-(define_expand "subhgen"
;;-  [(set (match_operand:HI 0 "register_operand" "=d")
;;-	(minus:HI (match_operand:HI 1 "register_operand" "0")
;;-		 (match_operand:HI 2 "address_operand" "min")))]
;;-    ""
;;-    "
;;-{
;;-    rtx sum;
;;-
;;-    if ((D_REG_P (operands[0])) && (GET_CODE (operands[2]) == MEM)) {
;;-	emit_insn (gen_subq (operands[0], operands[1], operands[2]));
;;-    }
;;-    else {
;;-	sum = (gen_rtx (PLUS, HImode, operands[1],
;;-	    negate_rtx (HImode, operands[2])));
;;-	emit_insn (gen_rtx (SET, HImode, operands[0], sum));
;;-    }
;;-    DONE;
;;-}")
    
(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand" "=q,!q")
	(minus:QI (match_operand:QI 1 "address_operand" "0,min")
		  (match_operand:QI 2 "address_operand" "min,0")))]
  ""
  "*
{
    if (which_alternative == 0) {
	if (operands[2] == const1_rtx)
	    return \"dec%0\\t\\t;subqi: R:%0 -= 1\";
	else
	    return \"sub%0\\t%2\\t;subqi: R:%0 -= %2\";
    }
    else {
	if (operands[1] == const1_rtx)
	    output_asm_insn(\"dec%0\\t\\t;subqi: R:%0 = 1 - R:%0\", operands);
	else
	    output_asm_insn(\"sub%0\\t%1\\t;subqi: R:%0 = %1 - R:%0\", operands);
	return \"neg%0\";
    }
}")

;;--------------------------------------------------------------------
;;- Multiply instructions.
;;--------------------------------------------------------------------

;;-(define_expand "mulsi3"
;;-  [(set (match_operand:SI 0 "register_operand" "=d")
;;-	(mult:SI (match_operand:SI 1 "register_operand" "0")
;;-		(match_operand:SI 2 "register_operand" "a")))]
;;-  ""
;;-  "
;;-{
;;-    emit_insn (gen_call_lib (
;;-	gen_rtx (SYMBOL_REF, Pmode, \"mul_si\"),
;;-	operands[0], operands[1], operands[2]));
;;-    DONE;
;;-}")

;;-(define_expand "mulhi3"
;;-  [(set (match_operand:HI 0 "register_operand" "=d")
;;-     (mult:HI (match_operand:HI 1 "register_operand" "0")
;;-             (match_operand:HI 2 "register_operand" "a")))]
;;-  ""
;;-  "
;;-{
;;-    emit_insn (gen_call_lib_hi (
;;-     gen_rtx (SYMBOL_REF, Pmode, \"mulhi3\"),
;;-     operands[0], operands[1], operands[2]));
;;-    DONE;
;;-}")

;;-
;;- neue Version von Ulrich Boetzel
;;- 1 Pushbefehl, da mult. kommutativ
;;- 
(define_insn "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=d")
        (mult:HI (match_operand:HI 1 "register_operand" "r")
                 (match_operand:HI 2 "register_operand" "r")))]
  ""
  "*
{
  output_asm_insn (\"pshs\\t%1,%2\\t; sichern Operanden R:%1,R:%2\", operands);
  output_asm_insn (\"jsr\\t_mulhi3\\t; Aufruf mulhi, Ergebnis in D\", 
                    operands);
  return \"leas\\t4,s\\t; Aufraeumen Stack\";
}")

(define_insn "mulqi3"
  [(set (match_operand:QI 0 "register_operand" "=q")
	(mult:QI (match_operand:QI 1 "register_operand" "%0")
		 (match_operand:QI 2 "byte_operand" "m")))]
  ""
  "*
{
    output_asm_insn (\"lda\\t%2\\t;mulhi: R:%0 = R:%0 * %2\", operands);
    return \"mul\";
}")

;;--------------------------------------------------------------------
;;- Divide instructions.
;;--------------------------------------------------------------------

;;-(define_expand "divsi3"
;;-  [(set (match_operand:SI 0 "data_reg_operand" "=d")
;;-	(div:SI (match_operand:SI 1 "data_reg_operand" "0")
;;-		(match_operand:SI 2 "register_operand" "a")))]
;;-  ""
;;-  "
;;-{
;;-    emit_insn (gen_call_lib (
;;-	gen_rtx (SYMBOL_REF, Pmode, \"divsi3\"),
;;-	operands[0], operands[1], operands[2]));
;;-    DONE;
;;-}")

(define_expand "divhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
     (div:HI (match_operand:HI 1 "data_reg_operand" "0")
             (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
    emit_insn (gen_call_lib_hi (
     gen_rtx (SYMBOL_REF, Pmode, \"divhi3\"),
     operands[0], operands[1], operands[2]));
    DONE;
}")

(define_expand "divqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q,g")
	(div:QI (match_operand:QI 1 "byte_reg_operand" "0,0")
		(match_operand:QI 2 "byte_operand" "qm,g")))]
  ""
  "
{
    emit_insn (gen_call_lib_qi (
     gen_rtx (SYMBOL_REF, Pmode, \"divqi3\"),
     operands[0], operands[1], operands[2]));
    DONE;
}")

(define_expand "udivhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
     (udiv:HI (match_operand:HI 1 "data_reg_operand" "0")
              (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
    emit_insn (gen_call_lib_hi (
     gen_rtx (SYMBOL_REF, Pmode, \"udivhi3\"),
     operands[0], operands[1], operands[2]));
    DONE;
}")


;;--------------------------------------------------------------------
;;- mod
;;--------------------------------------------------------------------

;;-(define_expand "modsi3"
;;-  [(set (match_operand:SI 0 "data_reg_operand" "=d")
;;-	(mod:SI (match_operand:SI 1 "data_reg_operand" "0")
;;-		(match_operand:SI 2 "register_operand" "a")))]
;;-  ""
;;-  "
;;-{
;;-    emit_insn (gen_call_lib (
;;-	gen_rtx (SYMBOL_REF, Pmode, \"mod_si\"),
;;-	operands[0], operands[1], operands[2]));
;;-    DONE;
;;-}")

(define_expand "modhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
     (mod:HI (match_operand:HI 1 "data_reg_operand" "0")
             (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
    emit_insn (gen_call_lib_hi (
     gen_rtx (SYMBOL_REF, Pmode, \"modhi3\"),
     operands[0], operands[1], operands[2]));
    DONE;
}")

(define_expand "modqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
	(mod:QI (match_operand:QI 1 "byte_reg_operand" "0")
		(match_operand:QI 2 "byte_operand" "g")))]
  ""
  "
{
    emit_insn (gen_call_lib_qi (
     gen_rtx (SYMBOL_REF, Pmode, \"modqi3\"),
     operands[0], operands[1], operands[2]));
    DONE;
}")

(define_expand "umodhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
     (umod:HI (match_operand:HI 1 "data_reg_operand" "0")
              (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
    emit_insn (gen_call_lib_hi (
     gen_rtx (SYMBOL_REF, Pmode, \"umodhi3\"),
     operands[0], operands[1], operands[2]));
    DONE;
}")



;;--------------------------------------------------------------------
;;- and, or, xor
;;--------------------------------------------------------------------

(define_insn "andsi3"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
	(and:SI (match_operand:SI 1 "data_reg_operand" "%0")
		(match_operand:SI 2 "address_operand" "min")))]
  ""
  "*
{
    int n;
    rtx xoperands[4];

    if (GET_CODE (operands[2]) == CONST_INT) {
	xoperands[0] = operands[0];
	xoperands[1] = operands[1];
	xoperands[3] = operands[2];
	xoperands[2] =
	    gen_rtx (CONST_INT, SImode,
	    (INTVAL (operands[2]) >> 8) & 0xff);
	output_asm_insn (\"anda\\t%2\\t;andsi: R:%0 AND %3\", xoperands);
	xoperands[2] =
	    gen_rtx (CONST_INT, SImode, INTVAL (operands[2]) & 0xff);
	output_asm_insn (\"andb\\t%2\", xoperands);
    }
    else {
	output_asm_insn (\"anda\\t%2\\t;andsi: R:%0 AND %2\", operands);
	output_asm_insn (\"andb\\t%L2\", operands);
    }
    return \"\";
}")

(define_insn "andhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
	(and:HI (match_operand:HI 1 "data_reg_operand" "%0")
		(match_operand:HI 2 "general_operand" "min")))]
  ""
  "*
{
    int n;
    rtx xoperands[4];

    if (GET_CODE (operands[2]) == CONST_INT) {
	xoperands[0] = operands[0];
	xoperands[1] = operands[1];
	xoperands[3] = operands[2];
	xoperands[2] =
	    gen_rtx (CONST_INT, HImode,
	    (INTVAL (operands[2]) >> 8) & 0xff);
	output_asm_insn (\"anda\\t%2\\t;andhi: R:%0 AND %3\", xoperands);
	xoperands[2] =
	    gen_rtx (CONST_INT, HImode, INTVAL (operands[2]) & 0xff);
	output_asm_insn (\"andb\\t%2\", xoperands);
    }
    else {
	output_asm_insn (\"anda\\t%2\\t;andhi: R:%0 AND %2\", operands);
	output_asm_insn (\"andb\\t%L2\", operands);
    }
    return \"\";
}")

(define_insn "andqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
	(and:QI (match_operand:QI 1 "byte_reg_operand" "%0")
		(match_operand:QI 2 "general_operand" "min")))]
  ""
  "and%0\\t%2\\t;andqi: R:%0 &= %2")

;;--------------------------------------------------------------------
;;- Bit set instructions.
;;--------------------------------------------------------------------

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
	(ior:SI (match_operand:SI 1 "data_reg_operand" "%0")
		(match_operand:SI 2 "address_operand" "min")))]
  ""
  "*
{
    int n;
    rtx xoperands[3];

    if (GET_CODE (operands[2]) == CONST_INT) {
	xoperands[0] = operands[0];
	xoperands[1] = operands[1];
	xoperands[2] =
	    gen_rtx (CONST_INT, SImode,
	    (INTVAL (operands[2]) >> 8) & 0xff);
	output_asm_insn (\"ora\\t%2\\t;iorsi: %0 OR %2\", xoperands);
	xoperands[2] =
	    gen_rtx (CONST_INT, SImode, INTVAL (operands[2]) & 0xff);
	output_asm_insn (\"orb\\t%2\", xoperands);
    }
    else {
	output_asm_insn (\"ora\\t%2\\t;iorsi: %0 OR %2\", operands);
	output_asm_insn (\"orb\\t%L2\", operands);
    }
    return \"\";
}")

(define_insn "iorhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
	(ior:HI (match_operand:HI 1 "data_reg_operand" "%0")
		(match_operand:HI 2 "general_operand" "min")))]
  ""
  "*
{
    int n;
    rtx xoperands[3];

    if (GET_CODE (operands[2]) == CONST_INT) {
	xoperands[0] = operands[0];
	xoperands[1] = operands[1];
	xoperands[2] =
	    gen_rtx (CONST_INT, HImode,
	    (INTVAL (operands[2]) >> 8) & 0xff);
	output_asm_insn (\"ora\\t%2\\t;iorhi: %0 OR %2\", xoperands);
	xoperands[2] =
	    gen_rtx (CONST_INT, HImode, INTVAL (operands[2]) & 0xff);
	output_asm_insn (\"orb\\t%2\", xoperands);
    }
    else {
	output_asm_insn (\"ora\\t%2\\t;iorhi: %0 OR %2\", operands);
	output_asm_insn (\"orb\\t%L2\", operands);
    }
    return \"\";
}")

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
	(ior:QI (match_operand:QI 1 "byte_reg_operand" "%0")
		(match_operand:QI 2 "general_operand" "min")))]
  ""
  "or%0\\t%2\\t;iorqi: %0 |= %2 ")

;;--------------------------------------------------------------------
;;- xor instructions.
;;--------------------------------------------------------------------

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
	(xor:SI (match_operand:SI 1 "data_reg_operand" "%0")
		(match_operand:SI 2 "address_operand" "min")))]
  ""
  "*
{
    int n;
    rtx xoperands[3];

    if (GET_CODE (operands[2]) == CONST_INT) {
	xoperands[0] = operands[0];
	xoperands[1] = operands[1];
	xoperands[2] =
	    gen_rtx (CONST_INT, SImode,
	    (INTVAL (operands[2]) >> 8) & 0xff);
	output_asm_insn (\"eora\\t%2\\t;xorsi: %0 XOR %2\", xoperands);
	xoperands[2] =
	    gen_rtx (CONST_INT, SImode, INTVAL (operands[2]) & 0xff);
	output_asm_insn (\"eorb\\t%2\", xoperands);
    }
    else {
	output_asm_insn (\"eora\\t%2\\t;xorsi: %0 XOR %2\", operands);
	output_asm_insn (\"eorb\\t%L2\", operands);
    }
    return \"\";
}")

(define_insn "xorhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
	(xor:HI (match_operand:HI 1 "data_reg_operand" "%0")
		(match_operand:HI 2 "address_operand" "min")))]
  ""
  "*
{
    int n;
    rtx xoperands[3];

    if (GET_CODE (operands[2]) == CONST_INT) {
	xoperands[0] = operands[0];
	xoperands[1] = operands[1];
	xoperands[2] =
	    gen_rtx (CONST_INT, HImode,
	    (INTVAL (operands[2]) >> 8) & 0xff);
	output_asm_insn (\"eora\\t%2\\t;xorhi: %0 XOR %2\", xoperands);
	xoperands[2] =
	    gen_rtx (CONST_INT, HImode, INTVAL (operands[2]) & 0xff);
	output_asm_insn (\"eorb\\t%2\", xoperands);
    }
    else {
	output_asm_insn (\"eora\\t%2\\t;xorhi: %0 XOR %2\", operands);
	output_asm_insn (\"eorb\\t%L2\", operands);
    }
    return \"\";
}")

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
	(xor:QI (match_operand:QI 1 "byte_reg_operand" "%0")
		(match_operand:QI 2 "byte_operand" "mK")))]
  ""
  "eor%0\\t%2\\t;xorqi: %0 $= %2 ")

;;--------------------------------------------------------------------
;;-  Complements
;;--------------------------------------------------------------------

(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=d,a")
	(neg:SI (match_operand:SI 1 "register_operand" "0,0")))]
  ""
  "*
{
    if (D_REG_P (operands[0])) {
	return \"coma\\t\\t;negsi: R:%0\;comb\;addd\\t#1\";
    }
    else if (A_REG_P (operands[0])) {
	output_asm_insn (\"exg\\td,%0\\t;negsi: R:%0 = -(R:%0)\", operands);
	return \"coma\;comb\;addd\\t#1\;exg\\td,%0\";
    }
    else {
	output_asm_insn (\"com\\t%0\\t;negsi: %0\;com\\t%L0\", operands);
	output_asm_insn (\"inc\\t%L0\", operands);
	output_asm_insn (\"bne\\t%l0\", operands);
	output_asm_insn (\"inc\\t%0\", operands);
	ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LI\",
	    CODE_LABEL_NUMBER (operands[0]));
	return \"\";
    }
}")

(define_insn "neghi2"
  [(set (match_operand:HI 0 "general_operand" "=d,a")
	(neg:HI (match_operand:HI 1 "general_operand" "0,0")))]
  ""
  "*
{
    if (D_REG_P (operands[0])) {
	return \"coma\\t\\t;neghi: R:%0\;comb\;addd\\t#1\";
    }
    else if (A_REG_P (operands[0])) {
	output_asm_insn (\"exg\\td,%0\\t;neghi: R:%0 = -(R:%0)\", operands);
	return \"coma\;comb\;addd\\t#1\;exg\\td,%0\";
    }
    else {
	output_asm_insn (\"com\\t%0\\t;neghi: %0\;com\\t%L0\", operands);
	output_asm_insn (\"inc\\t%L0\", operands);
	output_asm_insn (\"bne\\t%l0\", operands);
	output_asm_insn (\"inc\\t%0\", operands);
	ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LI\",
	    CODE_LABEL_NUMBER (operands[0]));
	return \"\";
    }
}")

(define_insn "negqi2"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
	(neg:QI (match_operand:QI 1 "byte_operand" "0")))]
  ""
  "*
{
    if (REG_P (operands[0]))
	return \"neg%0\\t\\t;negqi: R:%0\";
    else
	return \"neg\\t%0\\t;negqi: %0\";
}")

;;--------------------------------------------------------------------
;;-  
;;--------------------------------------------------------------------

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
	(not:SI (match_operand:SI 1 "data_reg_operand" "0")))]
  ""
  "coma\\t\\t;one_cmplsi:\;comb")

(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "general_operand" "=d")
	(not:HI (match_operand:HI 1 "general_operand" "0")))]
  ""
  "*
{
    if (REG_P (operands[0]))
	return \"coma\\t\\t;comhi: R:%0\;comb\";
    else
	return \"com\\t%0\\t;comhi: %0\;com\\t%L0\";
}")

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
	(not:QI (match_operand:QI 1 "byte_operand" "0")))]
  ""
  "*
{
    if (REG_P (operands[0]))
	return \"com%0\\t\\t;comqi: R:%0\";
    else
	return \"com\\t%0\\t;comqi: %0\";
}")

;;--------------------------------------------------------------------
;;- arithmetic shifts
;;--------------------------------------------------------------------
;;

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm,d")
	(ashift:SI (match_operand:SI 1 "general_operand" "0,0")
	     (match_operand:SI 2 "nonmemory_operand" "nI,a")))
   (clobber (match_dup  2))]
  ""
  "*
{
    int n;

    output_asm_insn (\"\\t\\t;ashlsi: %0 by %2\", operands);
    if (GET_CODE (operands[2]) == CONST_INT) {
	n = INTVAL (operands[2]) & 0x0f;
	while (n-- > 0) {
	    if (D_REG_P (operands[0]))
		output_asm_insn (\"aslb\;rola\", operands);
	    else
		output_asm_insn (\"asl\\t%L0\;rol\\t%0\", operands);
	}
    }
    else {
	output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
	output_asm_insn (\"bmi .+6\", operands);
	output_asm_insn (\"aslb\;rola\", operands);
	output_asm_insn (\"bra .-6\\t;loop\", operands);
    }
    return \"\";
}")

(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm,d")
        (ashift:HI (match_operand:HI 1 "general_operand" "0,0")
             (match_operand:HI 2 "nonmemory_operand" "nI,a")))
   (clobber (match_dup  2))]
  ""
  "*
{
    int n;
 
    output_asm_insn (\"\\t\\t;ashlhi: %0 by %2\", operands);
    if (GET_CODE (operands[2]) == CONST_INT) {
        n = INTVAL (operands[2]) & 0x0f;
        while (n-- > 0) {
            if (D_REG_P (operands[0]))
                output_asm_insn (\"aslb\;rola\", operands);
            else
                output_asm_insn (\"asl\\t%L0\;rol\\t%0\", operands);
        }
    }
    else {
        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
        output_asm_insn (\"bmi .+6\", operands);
        output_asm_insn (\"aslb\;rola\", operands);
        output_asm_insn (\"bra .-6\\t;loop\", operands);
    }
    return \"\";
}")


(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
	(ashift:QI (match_operand:QI 1 "byte_reg_operand" "0")
	     (match_operand:QI 2 "nonmemory_operand" "nI")))]
  ""
  "*
{
    int n;

    n = INTVAL (operands[2]) & 0x07;
    output_asm_insn (\"\\t\\t;ashlqi: %0 by %2\", operands);
    while (n-- > 0) {
	if (REG_P (operands[0]))
	    output_asm_insn (\"aslb\", operands);
	else
	    output_asm_insn (\"asl\\t%0\", operands);
    }
     return \"\";
}")

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm,d")
	(ashiftrt:SI (match_operand:SI 1 "general_operand" "0,0")
	     (match_operand:SI 2 "nonmemory_operand" "nI,a")))
   (clobber (match_dup  2))]
  ""
  "*
{
    int n;

    output_asm_insn (\"\\t\\t;ashrsi: %0 by %2\", operands);
    if (GET_CODE (operands[2]) == CONST_INT) {
	n = INTVAL (operands[2]) & 0x0f;
	while (n-- > 0) {
	    if (D_REG_P (operands[0]))
		output_asm_insn (\"asra\;rorb\", operands);
	    else
		output_asm_insn (\"asr\\t%0\;ror\\t%L0\", operands);
	}
    }
    else {
        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
        output_asm_insn (\"bmi .+6\", operands);
        output_asm_insn (\"asra\;rorb\", operands);
        output_asm_insn (\"bra .-6\\t;loop\", operands);
    }
     return \"\";
}")

(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm,d")
        (ashiftrt:HI (match_operand:HI 1 "general_operand" "0,0")
             (match_operand:HI 2 "nonmemory_operand" "nI,a")))
   (clobber (match_dup  2))]
  ""
  "*
{
    int n;
 
    output_asm_insn (\"\\t\\t;ashrhi: %0 by %2\", operands);
    if (GET_CODE (operands[2]) == CONST_INT) {
        n = INTVAL (operands[2]) & 0x0f;
        while (n-- > 0) {
            if (D_REG_P (operands[0]))
                output_asm_insn (\"asra\;rorb\", operands);
            else
                output_asm_insn (\"asr\\t%0\;ror\\t%L0\", operands);
        }
    }
    else {
        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
        output_asm_insn (\"bmi .+6\", operands);
        output_asm_insn (\"asra\;rorb\", operands);
        output_asm_insn (\"bra .-6\\t;loop\", operands);
    }
     return \"\";
}")


(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
	(ashiftrt:QI (match_operand:QI 1 "general_operand" "0")
	     (match_operand:QI 2 "nonmemory_operand" "rnI")))
  ]
  ""
  "*
{
    int n;

    n = INTVAL (operands[2]) & 0x07;
    output_asm_insn (\"\\t\\t;ashrqi: %0 by %2\", operands);
    while (n-- > 0) {
	if (Q_REG_P (operands[0]))
	    output_asm_insn (\"asrb\", operands);
	else
	    output_asm_insn (\"asr\\t%0\", operands);
    }
     return \"\";
}")

;;--------------------------------------------------------------------
;; logical shift instructions
;;--------------------------------------------------------------------

;;-(define_insn "lshlsi3"
;;-  [(set (match_operand:SI 0 "general_operand" "=dm,d")
;;-	(lshift:SI (match_operand:SI 1 "general_operand" "0,0")
;;-	     (match_operand:SI 2 "nonmemory_operand" "nI,a")))
;;-   (clobber (match_dup  2))]
;;-  ""
;;-  "*
;;-{
;;-    int n;
;;-
;;-    output_asm_insn (\"\\t\\t;lshlsi: %0 by %2\", operands);
;;-    if (GET_CODE (operands[2]) == CONST_INT) {
;;-	n = INTVAL (operands[2]) & 0x0f;
;;-	while (n-- > 0) {
;;-	    if (D_REG_P (operands[0]))
;;-		output_asm_insn (\"lslb\;rola\", operands);
;;-	    else
;;-		output_asm_insn (\"lsl\\t%L0\;rol\\t%0\", operands);
;;-	}
;;-    }
;;-    else {
;;-	output_asm_insn (\"lslb\;rola\", operands);
;;-	output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
;;-	output_asm_insn (\"bne .-4\\t;loop\", operands);
;;-    }
;;-    return \"\";
;;-}")
;;-
;;-(define_insn "lshlhi3"
;;-  [(set (match_operand:HI 0 "general_operand" "=dm,d")
;;-        (lshift:HI (match_operand:HI 1 "general_operand" "0,0")
;;-             (match_operand:HI 2 "nonmemory_operand" "nI,a")))
;;-   (clobber (match_dup  2))]
;;-  ""
;;-  "*
;;-{
;;-    int n;
;;- 
;;-    output_asm_insn (\"\\t\\t;lshlhi: %0 by %2\", operands);
;;-    if (GET_CODE (operands[2]) == CONST_INT) {
;;-        n = INTVAL (operands[2]) & 0x0f;
;;-        while (n-- > 0) {
;;-            if (D_REG_P (operands[0]))
;;-                output_asm_insn (\"lslb\;rola\", operands);
;;-            else
;;-                output_asm_insn (\"lsl\\t%L0\;rol\\t%0\", operands);
;;-        }
;;-    }
;;-    else {
;;-        output_asm_insn (\"lslb\;rola\", operands);
;;-        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
;;-        output_asm_insn (\"bne .-4\\t;loop\", operands);
;;-    }
;;-    return \"\";
;;-}")


(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm,d")
	(lshiftrt:SI (match_operand:SI 1 "general_operand" "0,0")
		     (match_operand:SI 2 "nonmemory_operand" "rnI,a")))
   (clobber (match_dup  2))]
  ""
  "*
{
    int n;

    output_asm_insn (\"\\t\\t;lshrsi: %0 by %2\", operands);
    if (GET_CODE (operands[2]) == CONST_INT) {
        n = INTVAL (operands[2]) & 0x0f;
        while (n-- > 0) {
	    if (D_REG_P (operands[0]))
	        output_asm_insn (\"lsra\;rorb\", operands);
	    else
	        output_asm_insn (\"lsr\\t%0\;ror\\t%L0\", operands);
        }
    }
    else {
        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
        output_asm_insn (\"bmi .+6\", operands);
        output_asm_insn (\"lsra\;rorb\", operands);
        output_asm_insn (\"bra .-6\\t;loop\", operands);
    }

     return \"\";
}")

(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm,d")
        (lshiftrt:HI (match_operand:HI 1 "general_operand" "0,0")
                     (match_operand:HI 2 "nonmemory_operand" "rnI,a")))
   (clobber (match_dup  2))]
  ""
  "*
{
    int n;
 
    output_asm_insn (\"\\t\\t;lshrhi: %0 by %2\", operands);
    if (GET_CODE (operands[2]) == CONST_INT) {
        n = INTVAL (operands[2]) & 0x0f;
        while (n-- > 0) {
            if (D_REG_P (operands[0]))
                output_asm_insn (\"lsra\;rorb\", operands);
            else
                output_asm_insn (\"lsr\\t%0\;ror\\t%L0\", operands);
        }
    }
    else {
        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
        output_asm_insn (\"bmi .+6\", operands);
        output_asm_insn (\"lsra\;rorb\", operands);
        output_asm_insn (\"bra .-6\\t;loop\", operands);
}
 
     return \"\";
}")


;;--------------------------------------------------------------------
;; rotate instructions
;;--------------------------------------------------------------------

(define_insn "rotlsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm")
	(rotate:SI (match_operand:SI 1 "general_operand" "0")
		   (match_operand:SI 2 "nonmemory_operand" "rnI")))]
  ""
  "rol.w %2,%0")

(define_insn "rotlhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm")
	(rotate:HI (match_operand:HI 1 "general_operand" "0")
		   (match_operand:HI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
    int n;

    n = INTVAL (operands[2]) & 0x07;
    output_asm_insn (\"\\t\\t;rotlhi: %0 by %2\", operands);
    while (n-- > 0) {
	if (Q_REG_P (operands[0]))
	    output_asm_insn (\"rolb\", operands);
	else
	    output_asm_insn (\"rol\\t%0\", operands);
    }
     return \"\";
}")

(define_insn "rotlqi3"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
        (rotate:QI (match_operand:QI 1 "byte_operand" "0")
                   (match_operand:HI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
    int n;
 
    n = INTVAL (operands[2]) & 0x07;
    output_asm_insn (\"\\t\\t;rotlqi: %0 by %2\", operands);
    while (n-- > 0) {
        if (Q_REG_P (operands[0]))
            output_asm_insn (\"rolb\", operands);
        else
            output_asm_insn (\"rol\\t%0\", operands);
    }
     return \"\";
}")

;;----------------

(define_insn "rotrsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm")
	(rotatert:SI (match_operand:SI 1 "general_operand" "0")
		     (match_operand:SI 2 "nonmemory_operand" "rnI")))]
  ""
  "ror.w %2,%0")

(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "byte_operand" "=dm")
	(rotatert:HI (match_operand:HI 1 "byte_operand" "0")
		     (match_operand:HI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
    int n;

    n = INTVAL (operands[2]) & 0x07;
    output_asm_insn (\"\\t\\t;rotrhi: %0 by %2\", operands);
    while (n-- > 0) {
	if (Q_REG_P (operands[0]))
	    output_asm_insn (\"rorb\", operands);
	else
	    output_asm_insn (\"ror\\t%0\", operands);
    }
     return \"\";
}")

(define_insn "rotrqi3"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
        (rotatert:QI (match_operand:QI 1 "byte_operand" "0")
                     (match_operand:QI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
    int n;
 
    n = INTVAL (operands[2]) & 0x07;
    output_asm_insn (\"\\t\\t;rotrqi: %0 by %2\", operands);
    while (n-- > 0) {
        if (Q_REG_P (operands[0]))
            output_asm_insn (\"rorb\", operands);
        else
            output_asm_insn (\"ror\\t%0\", operands);
    }
     return \"\";
}")

;;--------------------------------------------------------------------
;;-  Jumps and transfers
;;--------------------------------------------------------------------
;;-(define_expand "tablejump"
;;-  [(parallel [(set (pc) (match_operand 0 "" ""))
;;-              (use (label_ref (match_operand 1 "" "")))])]
;;-  ""
;;-  "
;;-{
;;-#ifdef CASE_VECTOR_PC_RELATIVE
;;-    operands[0] = gen_rtx (PLUS, HImode, pc_rtx,
;;-                           gen_rtx (SIGN_EXTEND, HImode, operands[0]));
;;-#endif
;;-}")
;;--------------------------------------------------------------------
;;-  Table jump
;;--------------------------------------------------------------------
;; Operand 0 is the address of the table element to use
;; operand 1 is the CODE_LABEL for the table
;;--------------------------------------------------------------------
(define_insn "tablejump"
   [(parallel [
        (set (pc) (match_operand:HI 0 "general_operand" "g"))
        (use (label_ref (match_operand 1 "" "")))])]
   ""
  "*
{
    if (A_REG_P (operands[0]))
       return \"jmp\\t,%0\\t;V1 tablejump R:%0 (table %1)\";
    else if (D_REG_P (operands[0]))
       return \"pshs %0\;jmp\\t[,s++]\\t;V2 tablejump R:%0 (table %1)\";
    else
       return \"jmp\\t[%0]\\t;V3 tablejump %0 (table %1)\";
}")


(define_insn "indirect_jumpSI"
  [(set (pc) 
       (match_operand:SI 0 "address_operand" "p"))
;;       (use (label_ref (match_operand 1 "" "")))
  ]
  ""
  "*
{
        output_asm_insn (\"jmp\\t%l0\", operands);
     return \"\";
}")

(define_insn "indirect_jump"
  [(set (pc)
       (match_operand:HI 0 "address_operand" "p"))
;;       (use (label_ref (match_operand 1 "" "")))
  ]
  ""
  "*
{
        output_asm_insn (\"jmp\\t%l0\", operands);
     return \"\";
}")

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bra\\t%l0\", operands);
    else
	output_asm_insn (\"jmp\\t%l0\", operands);
    return \"\";
}")

(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"beq\\t%l0\", operands);
    else
	output_asm_insn (\"lbeq\\t%l0\", operands);
    return \"\";
}")

(define_insn "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bne\\t%l0\", operands);
    else
	output_asm_insn (\"lbne\\t%l0\", operands);
    return \"\";
}")

(define_insn "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bgt\\t%l0\", operands);
    else
	output_asm_insn (\"lbgt\\t%l0\", operands);
    return \"\";
}")

(define_insn "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bhi\\t%l0\", operands);
    else
	output_asm_insn (\"lbhi\\t%l0\", operands);
    return \"\";
}")

(define_insn "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"blt\\t%l0\", operands);
    else
	output_asm_insn (\"lblt\\t%l0\", operands);
    return \"\";
}")

(define_insn "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"blo\\t%l0\", operands);
    else
	output_asm_insn (\"lblo\\t%l0\", operands);
    return \"\";
}")

(define_insn "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bge\\t%l0\", operands);
    else
	output_asm_insn (\"lbge\\t%l0\", operands);
    return \"\";
}")

(define_insn "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bhs\\t%l0\", operands);
    else
	output_asm_insn (\"lbhs\\t%l0\", operands);
    return \"\";
}")

(define_insn "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"ble\\t%l0\", operands);
    else
	output_asm_insn (\"lble\\t%l0\", operands);
    return \"\";
}")

(define_insn "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bls\\t%l0\", operands);
    else
	output_asm_insn (\"lbls\\t%l0\", operands);
    return \"\";
}")

;;--------------------------------------------------------------------
;;- Negative test and branch
;;--------------------------------------------------------------------
(define_insn ""
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bne\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbne\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"beq\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbeq\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"ble\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lble\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bls\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbls\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bge\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbge\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bhs\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbhs\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"blt\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lblt\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"blo\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lblo\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bgt\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbgt\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
    if (TARGET_SHORT_BRANCH)
	output_asm_insn (\"bhi\\t%l0\\t;rev\", operands);
    else
	output_asm_insn (\"lbhi\\t%l0\\t;rev\", operands);
    return \"\";
}")

;;--------------------------------------------------------------------
;;-  Calls
;;--------------------------------------------------------------------
;;
;; arg count word may be omitted to save a push and let gcc try to
;; combine the arg list pop.  RETURN_POPS_ARGS from tm.h decides this.

;;- Call a function that returns no value.
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "g")
	 (match_operand:SI 1 "general_operand" "g"))]
  ""
  "*
      return \"jsr\\t%0\\t;CALL: (VOIDmode) %0 (%a1 bytes)\";
  ")

(define_insn "call_value"
  [(set (match_operand 0 "" "=g")
	(call (match_operand:HI 1 "general_operand" "g")
	      (match_operand:SI 2 "general_operand" "g")))]
  ""
  "*
      return \"jsr\\t%1\\t;CALL: R:%0 = %1 (%a2 bytes)\";
  ")

;;- return insn not needed -- tej
;;(define_insn "return"
;;  [(return)]
;;  ""
;;  "rts")
;;

;;--------------------------------------------------------------------
;;-  Library call
;;--------------------------------------------------------------------
;; Produce a variant of the `call' insns that is used to call a
;; library routine.
;;
;; Operands are as follows:
;;	0 -- name of function (as SYMBOL_REF)
;;	1 -- output argument
;;	2 -- first input argument
;;	3 -- second input argument
;;--------------------------------------------------------------------
;;
;; The pattern given below just exists to show that we have 3 operands.
(define_expand "call_lib"
 [ (use (match_operand 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
 ""
 "
{
    emit_library_call (operands[0], 0, SImode,
	2, operands[2], SImode, operands[3], SImode);

    /*** assume library function returns value in R0 ***/
    emit_move_insn (operands[1], gen_rtx (REG, SImode, 0));
    DONE;
}")

(define_expand "call_lib_hi"
 [ (use (match_operand 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
 ""
 "
{
    emit_library_call (operands[0], 0, HImode,
        2, operands[2], HImode, operands[3], HImode);

    /*** assume library function returns value in R0 ***/
    emit_move_insn (operands[1], gen_rtx (REG, HImode, 0));
    DONE;
}")

(define_expand "call_lib_qi"
 [ (use (match_operand 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
 ""
 "
{
    emit_library_call (operands[0], 0, QImode,
        2, operands[2], QImode, operands[3], QImode);

    /*** assume library function returns value in R0 ***/
    emit_move_insn (operands[1], gen_rtx (REG, QImode, 0));
    DONE;
}")

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")
    

;;--------------------------------------------------------------------
;;- Peepholes
;;- TBD
;;--------------------------------------------------------------------

;; Optimize the case of following a register load with a test
;; of reg just moved.

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=r")
	(match_operand:SI 1 "memory_operand" "m"))
   (set (cc0) (match_operand:SI 2 "register_operand" "r"))]
  "operands[2] == operands[0]"
    "ld%0\\t%1\\t;movsi: %1 -> R:%0 w/ implied test of %2")

;; Optimize the case of following a register store with a test
;; of reg or mem just moved.

(define_peephole
  [(set (match_operand:HI 0 "memory_operand" "=m")
	(match_operand:HI 1 "register_operand" "r"))
   (set (cc0) (match_operand:HI 2 "general_operand" "g"))]
  "operands[2] == operands[0] || operands[2] == operands[1]"
    "st%1\\t%0\\t;movhi: R:%1 -> %0 w/ implied test of %2")
    
;; Optimize the (strange) case of following an SI register store
;; with a load of the reg just moved.
(define_peephole
  [(set (match_operand:SI 0 "memory_operand" "=m")
	(match_operand:SI 1 "register_operand" "r"))
  (set (match_operand:SI 2 "register_operand" "=r")
	(match_operand:SI 3 "memory_operand" "m"))]
  "operands[0] == operands[3] && operands[1] == operands[2]"
    "st%1\\t%0\\t;movsi: R:%1 -> %0 w/ redundant move of %3 -> %2")
    
;; Optimize the (strange) case of following an HI register store
;; with a load of the reg just moved.
(define_peephole
  [(set (match_operand:HI 0 "memory_operand" "=m")
	(match_operand:HI 1 "register_operand" "r"))
  (set (match_operand:HI 2 "register_operand" "=r")
	(match_operand:HI 3 "memory_operand" "m"))]
  "operands[0] == operands[3] && operands[1] == operands[2]"
    "st%1\\t%0\\t;movhi: R:%1 -> %0 w/ redundant move of %3 -> %2")
    
;;- Local variables:
;;- mode:emacs-lisp
;;- comment-start: ";;- "
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))
;;- eval: (modify-syntax-entry ?[ "(]")
;;- eval: (modify-syntax-entry ?] ")[")
;;- eval: (modify-syntax-entry ?{ "(}")
;;- eval: (modify-syntax-entry ?} "){")
;;- End:

